[{"/Users/keshawn/Desktop/toy-compiler/src/index.js":"1","/Users/keshawn/Desktop/toy-compiler/src/reportWebVitals.js":"2","/Users/keshawn/Desktop/toy-compiler/src/App.tsx":"3","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerIDE.js":"4","/Users/keshawn/Desktop/toy-compiler/src/registerServiceWorker.js":"5","/Users/keshawn/Desktop/toy-compiler/src/tools/common.js":"6","/Users/keshawn/Desktop/toy-compiler/src/MonkeyEvaluator.js":"7","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEditer.js":"8","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerParser.js":"9","/Users/keshawn/Desktop/toy-compiler/src/channel.worker.js":"10","/Users/keshawn/Desktop/toy-compiler/src/MonkeyLexer.ts":"11"},{"size":627,"mtime":1607961631519,"results":"12","hashOfConfig":"13"},{"size":362,"mtime":1607951722249,"results":"14","hashOfConfig":"13"},{"size":555,"mtime":1607952413652,"results":"15","hashOfConfig":"13"},{"size":3237,"mtime":1608000583548,"results":"16","hashOfConfig":"13"},{"size":4021,"mtime":1607134634067,"results":"17","hashOfConfig":"13"},{"size":1511,"mtime":1608000106157,"results":"18","hashOfConfig":"13"},{"size":18379,"mtime":1607930697711,"results":"19","hashOfConfig":"13"},{"size":12636,"mtime":1608000335611,"results":"20","hashOfConfig":"13"},{"size":22338,"mtime":1607918282383,"results":"21","hashOfConfig":"13"},{"size":1378,"mtime":1607964756008,"results":"22","hashOfConfig":"13"},{"size":9263,"mtime":1608000641772,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"t133d5",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"26"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/keshawn/Desktop/toy-compiler/src/index.js",[],["49","50"],"/Users/keshawn/Desktop/toy-compiler/src/reportWebVitals.js",[],"/Users/keshawn/Desktop/toy-compiler/src/App.tsx",[],["51","52"],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerIDE.js",[],"/Users/keshawn/Desktop/toy-compiler/src/registerServiceWorker.js",[],"/Users/keshawn/Desktop/toy-compiler/src/tools/common.js",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyEvaluator.js",["53"],"class BaseObject {\n\tconstructor () {\n\t\tthis.INTEGER_OBJ = \"INTEGER\"\n\t\tthis.BOOLEAN_OBJ = \"BOOLEAN\"\n\t\tthis.NULL_OBJ = \"NULL\"\n\t\tthis.ERROR_OBJ = \"Error\"\n\t\tthis.RETURN_VALUE_OBJECT = \"Return\"\n\t\tthis.FUNCTION_LITERAL = \"FunctionLiteral\"\n\t\tthis.FUNCTION_CALL = \"FunctionCall\"\n\t\tthis.STRING_OBJ = \"String\"\n\t\tthis.ARRAY_OBJ = \"Array\"\n\t\tthis.HASH_OBJ = \"Hash\"\n\t}\n\n\ttype() {return null}\n\n\tinspect() {return null}\n}\n\nclass Hash extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.keys = props.keys\n\t\tthis.values = props.values\n\t}\n\n\ttype () {\n\t\treturn this.HASH_OBJ\n\t}\n\n\tinspect () {\n\t\tlet s = \"{\"\n\t\tfor (let i = 0; i < this.keys.length; i++) {\n\t\t\tconst pair =`${this.keys[i].inspect()}: ${this.values[i].inspect()},`\n\t\t\ts += pair\n\t\t}\n\t\ts += \"}\"\n\t\treturn s\n\t}\n}\n\nclass Array extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.elements = props.elements\n\t}\n\n\ttype() {\n\t\treturn this.ARRAY_OBJ\n\t}\n\n\tinspect() {\n\t\tlet s = \"[\"\n\t\tfor (let i = 0; i < this.elements.length; i++) {\n\t\t\ts += this.elements[i].inspect()\n\t\t\ts += \",\"\n\t\t}\n\n\t\ts += \"]\"\n\t\treturn s\n\t}\n}\n\nclass StringCtr extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.value = props.value\n\t}\n\n\tinspect() {\n\t\treturn \"content of string is: \" + this.value\n\t}\n\n\ttype() {\n\t\treturn this.STRING_OBJ\n\t}\n}\n\nclass Integer extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.value = props.value\n\t}\n\n\tinspect () {\n\t\treturn \"integer with value:\" + this.value\n\t}\n\n\ttype () {\n\t\treturn this.INTEGER_OBJ\n\t}\n}\n\nclass BooleanCtr extends BaseObject {\n\tconstructor (props) {\n\t\tsuper(props)\n\t\tthis.value = props.value\n\t}\n\n\ttype () {\n\t\treturn this.BOOLEAN_OBJ\n\t}\n\n\tinspect () {\n\t\treturn \"boolean with value: \" + this.value\n\t}\n}\n\nclass Null extends BaseObject {\n\ttype () {\n\t\treturn this.NULL_OBJ\n\t}\n\tinspect () {\n\t\treturn \"null\"\n\t}\n}\n\nclass Error extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.msg = props.errMsg\n\t}\n\n\ttype () {\n\t\treturn this.ERROR_OBJ\n\t}\n\n\tinspect () {\n\t\treturn this.msg\n\t}\n}\n\nclass ReturnValues extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.valueObject = props.value\n\t}\n\n\ttype () {\n\t\treturn this.RETURN_VALUE_OBJECT\n\t}\n\n\tinspect() {\n\t\tthis.msg = \"return with : \" + this.valueObject.inspect()\n\t\treturn this.msg\n\t}\n}\n\nclass FunctionLiteral extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.token = props.token  //对应关键字fn\n\t\tthis.parameters = props.identifiers\n\t\tthis.blockStatement = props.blockStatement\n\t}\n\n\ttype() {\n\t\treturn this.FUNCTION_LITERAL\n\t}\n\n\tinspect() {\n\t\tlet s = \"fn(\"\n\t\tconst identifiers = []\n\t\tfor (let i = 0; i < this.paremeters.length; i++) {\n\t\t\tidentifiers[i] = this.parameters[i].tokenLiteral\n\t\t}\n\t\ts += identifiers.join(',')\n\t\ts += \"){\\n\"\n\t\ts += this.blockStatement.tokenLiteral\n\t\ts += \"\\n}\"\n\t\treturn s\n\t}\n}\n\nclass FunctionCall extends BaseObject {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.identifiers = props.identifiers\n\t\tthis.blockStatement = props.blockStatement\n\t\tthis.enviroment = undefined\n\t}\n}\n\nclass Enviroment {\n\tconstructor() {\n\t\tthis.map = {}\n\t\tthis.outer = undefined\n\t}\n\tget(name) {\n\t\tlet obj = this.map[name]\n\t\tif (obj !== undefined) {\n\t\t\treturn obj\n\t\t}\n\n\t\tif (this.outer !== undefined) {\n\t\t\tobj = this.outer.get(name)\n\t\t}\n\n\t\treturn obj\n\t}\n\tset(name, obj) {\n\t\tthis.map[name] = obj\n\t}\n}\n\nclass MonkeyEvaluator {\n\tconstructor (worker) {\n\t\tthis.enviroment = new Enviroment()\n\t\tthis.evalWorker = worker\n\t}\n\n\tnewEnclosedEnvironment(outerEnv) {\n\t\tconst env = new Enviroment()\n\t\tenv.outer = outerEnv\n\t\treturn env\n\t}\n\n\tbuiltins (name, args) { //name->api名称 args-->token类型\n\t\t//实现内嵌API\n\t\tconst props = {}\n\t\tswitch (name) {\n\t\t\tcase \"first\":\n\t\t\t\tif (args.length !== 1) {\n\t\t\t\t\treturn this.newError(\"Wrong number of arguments when calling len\")\n\t\t\t\t}\n\t\t\t\tif (args[0].type() !== args[0].ARRAY_OBJ) {\n\t\t\t\t\treturn this.newError(\"arguments of first must be ARRAY\")\n\t\t\t\t}\n\t\t\t\tif (args[0].elements.length > 0) {\n\t\t\t\t\tconsole.log(\"the first element of array is :\",\n\t\t\t\t\t\targs[0].elements[0].inspect())\n\t\t\t\t\treturn args[0].elements[0]\n\t\t\t\t}\n\t\t\t\treturn null\n\t\t\tcase \"rest\":\n\t\t\t\tif (args.length !== 1) {\n\t\t\t\t\treturn this.newError(\"Wrong number of arguments when calling len\")\n\t\t\t\t}\n\t\t\t\tif (args[0].type() !== args[0].ARRAY_OBJ) {\n\t\t\t\t\treturn this.newError(\"arguments of first must be ARRAY\")\n\t\t\t\t}\n\t\t\t\tif (args[0].elements.length > 1) {\n\t\t\t\t\t//去掉第一个元素\n\t\t\t\t\tprops.elements = args[0].elements.slice(1)\n\t\t\t\t\tconst obj = new Array(props)\n\t\t\t\t\tconsole.log(\"rest return: \", obj.inspect())\n\t\t\t\t\treturn obj\n\t\t\t\t}\n\t\t\t\treturn null\n\t\t\tcase \"append\":\n\t\t\t\tif (args.length !== 2) {\n\t\t\t\t\treturn this.newError(\"Wrong number of arguments when calling len\")\n\t\t\t\t}\n\t\t\t\tif (args[0].type() !== args[0].ARRAY_OBJ) {\n\t\t\t\t\treturn this.newError(\"arguments of first must be ARRAY\")\n\t\t\t\t}\n\n\t\t\t\tprops.elements = args[0].elements.slice(0)\n\t\t\t\tprops.elements.push(args[1])\n\t\t\t\tconst obj = new Array(props)\n\t\t\t\tconsole.log(\"new array after calling append is: \",\n\t\t\t\t\tobj.inspect())\n\t\t\t\treturn obj\n\n\t\t\tcase \"len\":\n\t\t\t\tif (args.length !== 1) {\n\t\t\t\t\treturn this.newError(\"Wrong number of arguments when calling len\")\n\t\t\t\t}\n\t\t\t\tswitch (args[0].type()) {\n\t\t\t\t\tcase args[0].STRING_OBJ:\n\t\t\t\t\t\tprops.value = args[0].value.length\n\t\t\t\t\t\tconst obj = new Integer(props)\n\t\t\t\t\t\tconsole.log(\"API len return: \",obj.inspect())\n\t\t\t\t\t\treturn obj\n\t\t\t\t\tcase args[0].ARRAY_OBJ:\n\t\t\t\t\t\tprops.value = args[0].elements.length\n\t\t\t\t\t\tconsole.log(\"len of array \"\n\t\t\t\t\t\t\t+ args[0].inspect()\n\t\t\t\t\t\t\t+ \" is \"\n\t\t\t\t\t\t\t+ props.value)\n\t\t\t\t\t\treturn new Integer(props)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn this.newError(\"bad data type\")\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn this.newError(\"unknown function call\")\n\t\t}\n\n\t}\n\tsetExecInfo(node) {\n\t\tconst props = {}\n\t\tif (node !== undefined) {\n\t\t\tprops['line'] = node.getLineNumber()\n\t\t}\n\n\t\tconst env = {}\n\t\tfor (const s in this.enviroment.map) {\n\t\t\tenv[s] = this.enviroment.map[s].inspect()\n\t\t}\n\t\tprops['env'] = env\n\t\treturn props\n\t}\n\t//单步调试\n\tpauseBeforeExec(node) {\n\t\tconst props = this.setExecInfo(node)\n\t\tthis.evalWorker.sendExecInfo(\"beforeExec\", props)\n\t\tthis.evalWorker.waitBeforeEval()\n\t}\n\teval (node) {\n\t\tconst props = {\n\t\t\tvalue: \"\",\n\t\t\tidentifiers: \"\",\n\t\t\ttoken:\"\",\n\t\t\telements: \"\",\n\t\t\tblockStatement: \"\"\n\t\t}\n\t\tswitch (node.type) {\n\t\t\tcase \"program\":\n\t\t\t\treturn this.evalProgram(node)\n\t\t\tcase \"HashLiteral\":\n\t\t\t\treturn this.evalHashLiteral(node)\n\t\t\tcase \"ArrayLiteral\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tconst elements = this.evalExpressions(node.elements)\n\t\t\t\tif (elements.length === 1 && this.isError(elements[0])) {\n\t\t\t\t\treturn elements[0]\n\t\t\t\t}\n\t\t\t\tprops.elements = elements\n\t\t\t\treturn new Array(props)\n\t\t\tcase \"IndexExpression\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tconst indexLeft = this.eval(node.left)\n\t\t\t\tif (this.isError(indexLeft)) {\n\t\t\t\t\treturn indexLeft\n\t\t\t\t}\n\t\t\t\tconst index = this.eval(node.index)\n\t\t\t\tif (this.isError(index)) {\n\t\t\t\t\treturn index\n\t\t\t\t}\n\t\t\t\tconst obj = this.evalIndexExpression(indexLeft , index)\n\t\t\t\tif (obj != null) {\n\t\t\t\t\tconsole.log(\"the index value is :\"\n\t\t\t\t\t\t+index.value\n\t\t\t\t\t\t+ \" with content : \"\n\t\t\t\t\t\t+ obj.inspect())\n\t\t\t\t}\n\t\t\t\treturn  obj\n\t\t\tcase \"String\":\n\t\t\t\tprops.value = node.tokenLiteral\n\t\t\t\treturn new StringCtr(props)\n\t\t\tcase \"LetStatement\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tconst letVal = this.eval(node.value)\n\t\t\t\tif (this.isError(letVal)) {\n\t\t\t\t\treturn letVal\n\t\t\t\t}\n\t\t\t\tthis.enviroment.set(node.name.tokenLiteral, letVal)\n\t\t\t\treturn letVal\n\t\t\tcase \"Identifier\":\n\t\t\t\tconsole.log(\"variable name is:\" + node.tokenLiteral)\n\t\t\t\tconst identifierValue = this.evalIdentifier(node, this.enviroment)\n\t\t\t\tconsole.log(\"it is binding value is \" + identifierValue.inspect())\n\t\t\t\treturn identifierValue\n\t\t\tcase \"FunctionLiteral\":\n\t\t\t\tprops.token = node.token\n\t\t\t\tprops.identifiers = node.parameters\n\t\t\t\tprops.blockStatement = node.body\n\t\t\t\tconst funObj = new FunctionCall(props)\n\t\t\t\tfunObj.enviroment  = this.newEnclosedEnvironment(this.enviroment)\n\t\t\t\treturn  funObj\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tconsole.log(\"execute a function with content:\", node.function.tokenLiteral)\n\t\t\t\tconsole.log(\"evaluate function call params:\")\n\t\t\t\tconst args = this.evalExpressions(node.arguments)\n\t\t\t\tif (args.length === 1 && this.isError(args[0])) {\n\t\t\t\t\treturn args[0]\n\t\t\t\t}\n\t\t\t\tconst functionCall = this.eval(node.function)\n\t\t\t\tif (this.isError(functionCall)) {\n\t\t\t\t\treturn this.builtins(node.function.tokenLiteral, args)\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\tconsole.log(args[i].inspect())\n\t\t\t\t}\n\t\t\t\tconst oldEnviroment = this.enviroment\n\t\t\t\t//设置新的变量绑定环境\n\t\t\t\tthis.enviroment = functionCall.enviroment\n\t\t\t\t//将输入参数名称与传入值在新环境中绑定\n\t\t\t\tfor (let i = 0; i < functionCall.identifiers.length; i++) {\n\t\t\t\t\tconst name = functionCall.identifiers[i].tokenLiteral\n\t\t\t\t\tconst val = args[i]\n\t\t\t\t\tthis.enviroment.set(name, val)\n\t\t\t\t}\n\t\t\t\t//执行函数体内代码\n\t\t\t\tconst result = this.eval(functionCall.blockStatement)\n\t\t\t\t//执行完函数后，里面恢复原有绑定环境\n\t\t\t\tthis.enviroment = oldEnviroment\n\t\t\t\tif (result.type() === result.RETURN_VALUE_OBJECT) {\n\t\t\t\t\tconsole.log(\"function call return with :\",\n\t\t\t\t\t\tresult.valueObject.inspect())\n\t\t\t\t\treturn result.valueObject\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\tcase \"Integer\":\n\t\t\t\tconsole.log(\"Integer with value:\", node.value)\n\t\t\t\tprops.value = node.value\n\t\t\t\treturn new Integer(props)\n\t\t\tcase \"Boolean\":\n\t\t\t\tprops.value = node.value\n\t\t\t\tconsole.log(\"Boolean with value:\", node.value)\n\t\t\t\treturn new BooleanCtr(props)\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\treturn this.eval(node.expression)\n\t\t\tcase \"PrefixExpression\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tconst prefixRight = this.eval(node.right)\n\t\t\t\tif (this.isError(prefixRight)) {\n\t\t\t\t\treturn prefixRight\n\t\t\t\t}\n\t\t\t\tconst preObj =  this.evalPrefixExpression(node.operator, prefixRight)\n\t\t\t\tconsole.log(\"eval prefix expression: \", preObj.inspect())\n\t\t\t\treturn preObj\n\t\t\tcase \"InfixExpression\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tconst infixLeft = this.eval(node.left)\n\t\t\t\tif (this.isError(infixLeft)) {\n\t\t\t\t\treturn infixLeft\n\t\t\t\t}\n\t\t\t\tconst infixRight = this.eval(node.right)\n\t\t\t\tif (this.isError(infixRight)) {\n\t\t\t\t\treturn infixRight\n\t\t\t\t}\n\t\t\t\treturn this.evalInfixExpression(node.operator, infixLeft, infixRight)\n\t\t\tcase \"IfExpression\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\treturn this.evalIfExpression(node)\n\t\t\tcase \"blockStatement\":\n\t\t\t\treturn this.evalStatements(node)\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.pauseBeforeExec(node)\n\t\t\t\tprops.value = this.eval(node.expression)\n\t\t\t\tif (this.isError(props.value)) {\n\t\t\t\t\treturn props.value\n\t\t\t\t}\n\t\t\t\tconst returnObj =  new ReturnValues(props)\n\t\t\t\tconsole.log(returnObj.inspect())\n\t\t\t\treturn returnObj\n\t\t\tdefault:\n\t\t\t\treturn new Null()\n\t\t}\n\t}\n\n\tevalHashLiteral(node) {\n\t\t/*\n\t\t先递归的解析哈希表的key，然后解析它的value,对于如下类型的哈希表代码\n\t\tlet add = fn (x, y) { return x+y};\n\t\tlet byOne = fn (z) { return z+1;}\n\t\t{add(1,2) : byOne(3)}\n\t\t编译器先执行add(1,2)得到3，然后执行byOne(3)得到4\n\t\t*/\n\t\tconst props = {\n\t\t\tkeys: [],\n\t\t\tvalues:[]\n\t\t}\n\t\tfor (let i = 0; i < node.keys.length; i++) {\n\t\t\tconst key = this.eval(node.keys[i])\n\t\t\tif (this.isError(key)) {\n\t\t\t\treturn key\n\t\t\t}\n\t\t\tif (this.hashtable(key) !== true) {\n\t\t\t\treturn  this.newError(\"unhashtable type:\" +\n\t\t\t\t\tkey.type())\n\t\t\t}\n\t\t\tconst value = this.eval(node.values[i])\n\t\t\tif (this.isError(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tprops.keys.push(key)\n\t\t\tprops.values.push(value)\n\t\t}\n\n\t\tconst hashObj = new Hash(props)\n\t\tconsole.log(\"eval hash object: \" + hashObj.inspect())\n\t\treturn hashObj\n\t}\n\n\thashtable(node) {\n\t\treturn node.type() === node.INTEGER_OBJ ||\n\t\t\tnode.type() === node.STRING_OBJ ||\n\t\t\tnode.type() === node.BOOLEAN_OBJ;\n\t}\n\n\tevalIndexExpression(left, index) {\n\t\tif (left.type() === left.ARRAY_OBJ &&\n\t\t\tindex.type() === index.INTEGER_OBJ) {\n\t\t\treturn this.evalArrayIndexExpression(left, index)\n\t\t}\n\t\tif (left.type() === left.HASH_OBJ) {\n\t\t\treturn this.evalHashIndexExpression(left, index)\n\t\t}\n\t}\n\n\tevalHashIndexExpression(hash, index) {\n\t\tif (!this.hashtable(index)) {\n\t\t\treturn  this.newError(\"unhashtable type: \" + index.type())\n\t\t}\n\n\t\tfor (let i = 0; i < hash.keys.length; i++) {\n\t\t\tif (hash.keys[i].value === index.value) {\n\t\t\t\tconsole.log(\"return hash value :\" +\n\t\t\t\t\thash.values[i])\n\t\t\t\treturn hash.values[i]\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\tevalArrayIndexExpression(array, index) {\n\t\tconst idx = index.value\n\t\tconst max = array.elements.length - 1\n\t\tif (idx < 0 || idx > max) {\n\t\t\treturn this.newError(\"Array out of bounds \")\n\t\t}\n\t\treturn array.elements[idx]\n\t}\n\n\tevalExpressions(exps) {\n\t\tconst result = []\n\t\tfor(let i = 0; i < exps.length; i++) {\n\t\t\tconst evaluated = this.eval(exps[i])\n\t\t\tif (this.isError(evaluated)) {\n\t\t\t\treturn evaluated\n\t\t\t}\n\t\t\tresult[i] = evaluated\n\t\t}\n\t\treturn result\n\t}\n\n\tevalIdentifier(node, env) {\n\t\tconst val = env.get(node.tokenLiteral)\n\t\tif (val === undefined) {\n\t\t\treturn this.newError(\"identifier no found:\"+node.name)\n\t\t}\n\n\t\treturn val\n\t}\n\n\tevalProgram (program) {\n\t\tlet result = null\n\t\tfor (let i = 0; i < program.statements.length; i++) {\n\t\t\tresult = this.eval(program.statements[i])\n\n\t\t\tconst props = this.setExecInfo()\n\t\t\tif (result.type() === result.RETURN_VALUE_OBJECT) {\n\t\t\t\tthis.evalWorker.sendExecInfo(\"finishExec\", props)\n\t\t\t\treturn result.valueObject\n\t\t\t}\n\n\t\t\tif (result.type() === result.NULL_OBJ) {\n\t\t\t\tthis.evalWorker.sendExecInfo(\"finishExec\", props)\n\t\t\t\treturn result\n\t\t\t}\n\n\t\t\tif (result.type === result.ERROR_OBJ) {\n\t\t\t\tthis.evalWorker.sendExecInfo(\"finishExec\", props)\n\t\t\t\tconsole.log(result.msg)\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t\tconst props = this.setExecInfo()\n\t\tthis.evalWorker.sendExecInfo(\"finishExec\", props)\n\t\treturn result\n\t}\n\n\tisError(obj) {\n\t\tif (obj !== undefined) {\n\t\t\treturn obj.type() === obj.ERROR_OBJ\n\t\t}\n\n\t\treturn false\n\t}\n\n\tnewError(msg) {\n\t\tconst props = {}\n\t\tprops.errMsg = msg\n\t\treturn new Error(props)\n\t}\n\n\tevalIfExpression(ifNode) {\n\t\tconsole.log(\"begin to eval if statement\")\n\t\tconst condition = this.eval(ifNode.condition)\n\n\t\tif (this.isError(condition)) {\n\t\t\treturn condition\n\t\t}\n\n\t\tif (this.isTruthy(condition)) {\n\t\t\tconsole.log(\"condition in if holds, exec statements in if block\")\n\t\t\treturn this.eval(ifNode.consequence)\n\t\t} else if (ifNode.alternative != null) {\n\t\t\tconsole.log(\"condition in if no holds, exec statements in else block\")\n\t\t\treturn this.eval(ifNode.alternative)\n\t\t} else {\n\t\t\tconsole.log(\"condition in if no holds, exec nothing!\")\n\t\t\treturn null\n\t\t}\n\t}\n\n\tisTruthy(condition) {\n\t\tif (condition.type() === condition.INTEGER_OBJ) {\n\t\t\treturn condition.value !== 0;\n\n\t\t}\n\n\t\tif (condition.type() === condition.BOOLEAN_OBJ) {\n\t\t\treturn condition.value\n\t\t}\n\n\t\treturn condition.type() !== condition.NULL_OBJ;\n\n\n\t}\n\n\tevalStatements(node) {\n\t\tlet result = null\n\t\tfor (let i = 0; i < node.statements.length; i++) {\n\t\t\tresult = this.eval(node.statements[i])\n\t\t\tif (result.type() === result.RETURN_VALUE_OBJECT\n\t\t\t\t|| result.type() === result.ERROR_OBJ) {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\tevalInfixExpression(operator, left, right) {\n\t\tif (left.type() !== right.type()) {\n\t\t\treturn  this.newError(\n\t\t\t\t\"type mismatch: \"\n\t\t\t\t+ left.type() + \" and \" + right.type()\n\t\t\t)\n\t\t}\n\n\t\tif (left.type() === left.INTEGER_OBJ\n\t\t\t&& right.type() === right.INTEGER_OBJ) {\n\t\t\treturn this.evalIntegerInfixExpression(\n\t\t\t\toperator, left, right)\n\t\t}\n\n\t\tif (left.type() === left.STRING_OBJ\n\t\t\t&& right.type() === right.STRING_OBJ) {\n\t\t\treturn this.evalStringInfixExpression(\n\t\t\t\toperator, left, right)\n\t\t}\n\n\t\tconst props = {}\n\t\tif (operator === '===') {\n\t\t\tprops.value = (left.value === right.value)\n\t\t\tconsole.log(\"result on boolean operation of \"\n\t\t\t\t+ operator\n\t\t\t\t+ \" is \"\n\t\t\t\t+ props.value)\n\t\t\treturn new BooleanCtr(props)\n\t\t} else if (operator === '!==') {\n\t\t\tprops.value = (left.value !== right.value)\n\t\t\tconsole.log(\"result on boolean operation of \" + operator\n\t\t\t\t+ \" is \" + props.value)\n\t\t\treturn new BooleanCtr(props)\n\t\t}\n\n\t\treturn  this.newError(\"unknown operator: \"+ operator)\n\t}\n\n\tevalStringInfixExpression(operator, left, right) {\n\t\tif (operator !== \"+\") {\n\t\t\treturn this.newError(\"unknown operator for string operation\")\n\t\t}\n\n\t\tconst leftVal = left.value\n\t\tconst rightVal = right.value\n\t\tconst props = {}\n\t\tprops.value = leftVal + rightVal\n\t\tconsole.log(\"reuslt of string add is: \", props.value)\n\t\treturn new StringCtr(props)\n\t}\n\n\tevalIntegerInfixExpression(operator, left, right) {\n\t\tconst leftVal = left.value\n\t\tconst rightVal = right.value\n\t\tconst props = {}\n\t\tlet resultType = \"integer\"\n\n\t\tswitch (operator) {\n\t\t\tcase \"+\":\n\t\t\t\tprops.value = leftVal + rightVal\n\t\t\t\tbreak;\n\t\t\tcase \"-\":\n\t\t\t\tprops.value = leftVal - rightVal\n\t\t\t\tbreak;\n\t\t\tcase \"*\":\n\t\t\t\tprops.value = leftVal * rightVal\n\t\t\t\tbreak;\n\t\t\tcase \"/\":\n\t\t\t\tprops.value = leftVal / rightVal\n\t\t\t\tbreak;\n\t\t\tcase \"===\":\n\t\t\t\tresultType = \"boolean\"\n\t\t\t\tprops.value = (leftVal === rightVal)\n\t\t\t\tbreak;\n\t\t\tcase \"!==\":\n\t\t\t\tresultType = \"boolean\"\n\t\t\t\tprops.value = (leftVal !== rightVal)\n\t\t\t\tbreak\n\t\t\tcase \">\":\n\t\t\t\tresultType = \"boolean\"\n\t\t\t\tprops.value = (leftVal > rightVal)\n\t\t\t\tbreak\n\t\t\tcase \"<\":\n\t\t\t\tresultType = \"boolean\"\n\t\t\t\tprops.value = (leftVal < rightVal)\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\treturn this.newError(\"unknown operator for Integer\")\n\t\t}\n\t\tconsole.log(\"eval infix expression result is:\", props.value)\n\t\tlet result = null\n\t\tif (resultType === \"integer\") {\n\t\t\tresult = new Integer(props)\n\t\t} else if (resultType === \"boolean\") {\n\t\t\tresult = new BooleanCtr(props)\n\t\t}\n\n\t\treturn result\n\t}\n\n\tevalPrefixExpression(operator, right) {\n\t\tswitch (operator) {\n\t\t\tcase \"!\":\n\t\t\t\treturn this.evalBangOperatorExpression(right)\n\t\t\tcase \"-\":\n\t\t\t\treturn this.evalMinusPrefixOperatorExpression(right)\n\t\t\tdefault:\n\t\t\t\treturn this.newError(\"unknown operator:\", operator, right.type())\n\t\t}\n\t}\n\t//取反\n\tevalBangOperatorExpression(right) {\n\t\tvar props = {}\n\t\tif (right.type() === right.BOOLEAN_OBJ) {\n\t\t\tif (right.value === true) {\n\t\t\t\tprops.value = false\n\t\t\t}\n\n\t\t\tif (right.value === false) {\n\t\t\t\tprops.value = true\n\t\t\t}\n\t\t}\n\n\t\tif (right.type() === right.INTEGER_OBJ) {\n\t\t\tprops.value = right.value === 0;\n\t\t}\n\n\t\tif (right.type() === right.NULL_OBJ) {\n\t\t\tprops.value = true\n\t\t}\n\n\t\treturn new BooleanCtr(props)\n\t}\n\n\tevalMinusPrefixOperatorExpression(right) {\n\t\tif (right.type() !== right.INTEGER_OBJ) {\n\t\t\treturn this.newError(\"unknown operator:- \", right.type())\n\t\t}\n\t\tconst props = {}\n\t\tprops.value = -right.value\n\t\treturn new Integer(props)\n\t}\n}\n\nexport default MonkeyEvaluator","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEditer.js",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerParser.js",[],"/Users/keshawn/Desktop/toy-compiler/src/channel.worker.js",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyLexer.ts",[],{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"54","replacedBy":"58"},{"ruleId":"56","replacedBy":"59"},{"ruleId":"60","severity":1,"message":"61","line":149,"column":7,"nodeType":"62","messageId":"63","endLine":149,"endColumn":22},"no-native-reassign",["64"],"no-negated-in-lhs",["65"],["64"],["65"],"no-unused-vars","'FunctionLiteral' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]
[{"/Users/keshawn/Desktop/toy-compiler/src/index.js":"1","/Users/keshawn/Desktop/toy-compiler/src/reportWebVitals.js":"2","/Users/keshawn/Desktop/toy-compiler/src/registerServiceWorker.js":"3","/Users/keshawn/Desktop/toy-compiler/src/MonkeyLexer.ts":"4","/Users/keshawn/Desktop/toy-compiler/src/tools/common.ts":"5","/Users/keshawn/Desktop/toy-compiler/src/channel.worker.js":"6","/Users/keshawn/Desktop/toy-compiler/src/eval.worker.js":"7","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerParser/MonkeyCompilerParser.ts":"8","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerParser/ParserCtr.ts":"9","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEditer.tsx":"10","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEvaluator/MonkeyEvaluator.ts":"11","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEvaluator/EvaluatorCtr.ts":"12","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerIDE.tsx":"13"},{"size":626,"mtime":1608206006363,"results":"14","hashOfConfig":"15"},{"size":362,"mtime":1607951722249,"results":"16","hashOfConfig":"15"},{"size":4021,"mtime":1607134634067,"results":"17","hashOfConfig":"15"},{"size":9522,"mtime":1608202736625,"results":"18","hashOfConfig":"15"},{"size":1530,"mtime":1608024203009,"results":"19","hashOfConfig":"15"},{"size":1379,"mtime":1608028611732,"results":"20","hashOfConfig":"15"},{"size":1080,"mtime":1608190895132,"results":"21","hashOfConfig":"15"},{"size":15228,"mtime":1608129824185,"results":"22","hashOfConfig":"15"},{"size":8910,"mtime":1608111732441,"results":"23","hashOfConfig":"15"},{"size":13635,"mtime":1608207116753,"results":"24","hashOfConfig":"15"},{"size":15655,"mtime":1608201912087,"results":"25","hashOfConfig":"15"},{"size":4166,"mtime":1608201884520,"results":"26","hashOfConfig":"15"},{"size":3536,"mtime":1608205304599,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"t133d5",{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"39"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/keshawn/Desktop/toy-compiler/src/index.js",[],"/Users/keshawn/Desktop/toy-compiler/src/reportWebVitals.js",[],["59","60"],"/Users/keshawn/Desktop/toy-compiler/src/registerServiceWorker.js",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyLexer.ts",[],"/Users/keshawn/Desktop/toy-compiler/src/tools/common.ts",[],["61","62"],"/Users/keshawn/Desktop/toy-compiler/src/channel.worker.js",[],"/Users/keshawn/Desktop/toy-compiler/src/eval.worker.js",[],["63","64"],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerParser/MonkeyCompilerParser.ts",[],["65","66"],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerParser/ParserCtr.ts",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEditer.tsx",["67"],"import React, { Component } from \"react\";\nimport rangy from \"rangy/lib/rangy-selectionsaverestore\";\nimport MonkeyLexer, { KeyWordMap, Token } from \"./MonkeyLexer\";\nimport { Popover } from \"antd\";\nimport MonkeyCompilerIDE from \"./MonkeyCompilerIDE\";\nimport { changeSpaceToNBSP, createLineSpan } from \"./tools/common\"\ninterface State {\n  popoverStyle: {\n    title: string,\n    content: string\n  }\n}\ninterface Props {\n  keyWords: KeyWordMap\n}\ninterface Element {\n  begin: number\n  end: number\n  node: CurrentElement\n  token: Token\n\n}\ninterface CurrentElement extends Text {\n  data: string\n  identifierCount: number\n  keyWordCount: number\n}\nexport default class MonkeyCompilerEditer extends Component<Props, State> {\n  keyWords: KeyWordMap;\n  keyWordClass: string;\n  keyWordElementArray: Array<Element>;\n  identifierElementArray: Array<Element>;\n  textNodeArray: Array<Text>;\n  lineNodeClass: string;\n  lineSpanNode: string;\n  identifierClass: string;\n  breakPointClass: string;\n  keyToIngore: Array<string>;\n  bpMap: {};\n  ide: MonkeyCompilerIDE;\n  divInstance: HTMLElement;\n  lastBegin: number;\n  lexer: MonkeyLexer;\n  currentElement: CurrentElement;\n  constructor(props) {\n    super(props);\n    this.state = {\n      popoverStyle: {\n        title: \"\",\n        content: \"\"\n      }\n    }\n    this.keyWords = props.keyWords;\n    rangy.init();\n    this.keyWordClass = \"keyword\";\n    this.keyWordElementArray = [];\n    this.identifierElementArray = [];\n    this.textNodeArray = [];\n    this.lineNodeClass = \"line\";\n    this.lineSpanNode = \"LineSpan\";\n    this.identifierClass = \"Identifier\";\n    this.breakPointClass = \"breakpoint\";\n\n    this.keyToIngore = [\n      \"Enter\",\n      \" \",\n      \"ArrowUp\",\n      \"ArrowDown\",\n      \"ArrowLeft\",\n      \"ArrowRight\",\n    ];\n    createLineSpan()\n    this.bpMap = {};\n    this.ide = null;\n  }\n\n  initPopoverControl() {\n    this.setState({\n      popoverStyle: {\n        title: \"\",\n        content: \"\"\n      }\n    })\n  }\n\n  getContent(): string {\n    return this.divInstance.innerText;\n  }\n  // dom树，找到节点，提供给lexer进行分词\n  changeNode(n) {\n    if (n.childNodes) {\n      const f = n.childNodes;\n      for (const node of f) {\n        this.changeNode(node);\n      }\n    }\n    if (n.data) {\n      this.lastBegin = 0;\n      n.keyWordCount = 0;\n      n.identifierCount = 0;\n      const lexer = new MonkeyLexer(n.data);\n      this.lexer = lexer;\n      lexer.setLexingObserver(this, n);\n      lexer.lexing();\n    }\n  }\n  // 观察者模式  回调获得token对象，以及初始及结束位置\n  notifyTokenCreation(token, elementNode, begin, end) {\n    const e = {\n      node: elementNode,\n      begin: begin,\n      end: end,\n      token: token\n    };\n\n    if (this.keyWords[token.getLiteral()] !== undefined) {\n      elementNode.keyWordCount++;\n      this.keyWordElementArray.push(e);\n    }\n\n    if (\n      elementNode.keyWordCount === 0 &&\n      token.getType() === this.lexer.IDENTIFIER\n    ) {\n      elementNode.identifierCount++;\n      this.identifierElementArray.push(e); //存入关键词数组\n    }\n  }\n\n  hightLightKeyWord(token: Token, elementNode: CurrentElement, begin: number, end: number) {\n    let strBefore = elementNode.data.substr(\n      this.lastBegin,\n      begin - this.lastBegin\n    );\n    //空格转换为unicode\n    strBefore = changeSpaceToNBSP(strBefore);\n\n    const textNode = document.createTextNode(strBefore);\n    const parentNode = elementNode.parentNode;\n    parentNode.insertBefore(textNode, elementNode);\n    this.textNodeArray.push(textNode);\n    //  关键词设置一个span标签\n    const span = document.createElement(\"span\");\n    span.style.color = \"green\";\n    span.classList.add(this.keyWordClass);\n    span.appendChild(document.createTextNode(token.getLiteral()));\n    parentNode.insertBefore(span, elementNode);\n\n    this.lastBegin = end - 1;\n\n    elementNode.keyWordCount--;\n  }\n\n  hightLightSyntax() {\n\n    this.textNodeArray = [];\n\n    for (let i = 0; i < this.keyWordElementArray.length; i++) {\n      const e = this.keyWordElementArray[i];\n      this.currentElement = e.node;\n      this.hightLightKeyWord(e.token, e.node, e.begin, e.end);\n\n      if (this.currentElement.keyWordCount === 0) {\n        const end = this.currentElement.data.length;\n        let lastText = this.currentElement.data.substr(this.lastBegin, end);\n        lastText = changeSpaceToNBSP(lastText);\n        const parent = this.currentElement.parentNode;\n        const lastNode = document.createTextNode(lastText);\n        parent.insertBefore(lastNode, this.currentElement);\n        // 解析最后一个节点，这样可以为关键字后面的变量字符串设立popover控件\n        this.textNodeArray.push(lastNode);\n        parent.removeChild(this.currentElement);\n      }\n    }\n    this.keyWordElementArray = [];\n  }\n\n  getCaretLineNode() {\n    const sel = document.getSelection();\n    //得到光标所在行的node对象\n    const nd = sel.anchorNode;\n    //查看其父节点是否是span,如果不是，\n    //我们插入一个span节点用来表示光标所在的行\n    let currentLineSpan = null;\n    const elements = document.getElementsByClassName(this.lineSpanNode);\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.contains(nd)) {\n        currentLineSpan = element;\n      }\n      //删除自动复制的span class属性\n      while (element.classList.length > 0) {\n        element.classList.remove(element.classList.item(0));\n      }\n      element.classList.add(this.lineSpanNode);\n      element.classList.add(this.lineNodeClass + String(i));\n    }\n\n    if (currentLineSpan !== null) {\n\n      currentLineSpan.onclick = (e) => {\n        this.createBreakPoint(e);\n      }\n      return currentLineSpan;\n    }\n\n    //计算一下当前光标所在节点的前面有多少个div节点，\n    //前面的div节点数就是光标所在节点的行数\n    const divElements = this.divInstance.children;\n    let l = 0;\n    for (let i = 0; i < divElements.length; i++) {\n      if (divElements[i].tagName === \"DIV\" && divElements[i].contains(nd)) {\n        l = i;\n        break;\n      }\n    }\n\n    const spanNode = document.createElement(\"span\") as HTMLElement;\n    spanNode.classList.add(this.lineSpanNode);\n    spanNode.classList.add(this.lineNodeClass + String(l));\n    spanNode.dataset.lineNum = String(l);\n\n    spanNode.onclick = (e) => {\n      this.createBreakPoint(e);\n    };\n\n    nd.parentNode.replaceChild(spanNode, nd);\n    spanNode.appendChild(nd);\n    return spanNode;\n  }\n\n  setIDE(ide: MonkeyCompilerIDE): void {\n    this.ide = ide;\n  }\n\n  createBreakPoint(elem) {\n    if (elem.toElement.classList.item(0) !== this.lineSpanNode) {\n      return;\n    }\n    const element = elem.toElement\n    //是否已存在断点，是的话就取消断点\n    if (element.dataset.bp === \"true\") {\n      let bp = element.previousSibling;\n      bp.remove();\n      element.dataset.bp = \"false\";\n      delete this.bpMap[\"\" + element.dataset.lineNum];\n      if (this.ide) {\n        this.ide.updateBreakPointMap(this.bpMap);\n      }\n      return;\n    }\n\n    //构造一个红色圆点\n    element.dataset.bp = \"true\";\n    this.bpMap[\"\" + element.dataset.lineNum] = element.dataset.lineNum;\n    const bp = document.createElement(\"span\");\n    bp.style.height = \"10px\";\n    bp.style.width = \"10px\";\n    bp.style.backgroundColor = \"red\";\n    bp.style.borderRadius = \"50%\";\n    bp.style.display = \"inline-block\";\n    bp.classList.add(this.breakPointClass);\n    element.parentNode.insertBefore(bp, element.parentNode.firstChild);\n    if (this.ide != null) {\n      this.ide.updateBreakPointMap(this.bpMap);\n    }\n  }\n\n  handleIdentifierOnMouseOver(e) {\n    e.currentTarget.isOver = true;\n    const token = e.currentTarget.token;\n    this.setState({\n      popoverStyle: {\n        title: \"Syntax\",\n        content: \"name:\" + token.getLiteral() + \"\\nType:\" + token.getType()\n      }\n    })\n    if (this.ide) {\n      const env = this.ide.getSymbolInfo(token.getLiteral());\n      if (env) {\n        this.setState({\n          popoverStyle: {\n            title: token.getLiteral(),\n            content: env\n          }\n        })\n      }\n    }\n\n    this.setState(this.state);\n  }\n\n  handleIdentifierOnMouseOut() {\n    this.initPopoverControl();\n  }\n\n  addPopoverSpanToIdentifier(token, elementNode, begin, end) {\n    let strBefore = elementNode.data.substr(\n      this.lastBegin,\n      begin - this.lastBegin\n    );\n    strBefore = changeSpaceToNBSP(strBefore);\n    const textNode = document.createTextNode(strBefore);\n    const parentNode = elementNode.parentNode;\n    parentNode.insertBefore(textNode, elementNode);\n\n    const span = document.createElement(\"span\");\n    span.onmouseenter = this.handleIdentifierOnMouseOver.bind(this);\n    span.onmouseleave = this.handleIdentifierOnMouseOut.bind(this);\n    span.classList.add(this.identifierClass);\n    span.appendChild(document.createTextNode(token.getLiteral()));\n    // @ts-ignore  \"setAttribute\" doesn't work\n    span.token = token;\n    parentNode.insertBefore(span, elementNode);\n    this.lastBegin = end - 1;\n    elementNode.identifierCount--;\n  }\n\n  addPopoverByIdentifierArray(): void {\n    //该函数的逻辑跟hightLightSyntax一摸一样\n    for (let i = 0; i < this.identifierElementArray.length; i++) {\n      //用 span 将每一个变量包裹起来，这样鼠标挪上去时就可以弹出popover控件\n      const e = this.identifierElementArray[i];\n      this.currentElement = e.node;\n      //找到每个IDENTIFIER类型字符串的起始和末尾，给他们添加span标签\n      this.addPopoverSpanToIdentifier(e.token, e.node, e.begin, e.end);\n\n      if (this.currentElement.identifierCount === 0) {\n        const end = this.currentElement.data.length;\n        let lastText = this.currentElement.data.substr(this.lastBegin, end);\n        lastText = changeSpaceToNBSP(lastText);\n        const parent = this.currentElement.parentNode;\n        const lastNode = document.createTextNode(lastText);\n        parent.insertBefore(lastNode, this.currentElement);\n        parent.removeChild(this.currentElement);\n      }\n    }\n\n    this.identifierElementArray = [];\n  }\n\n  preparePopoverForIdentifers(): void {\n    if (this.textNodeArray.length > 0) {\n      //fix bug\n      this.identifierElementArray = [];\n      for (let i = 0; i < this.textNodeArray.length; i++) {\n        //将text 节点中的文本提交给词法解析器抽取IDENTIFIER\n        this.changeNode(this.textNodeArray[i]);\n        this.addPopoverByIdentifierArray();\n      }\n      this.textNodeArray = [];\n    } else {\n      //为解析出的IDENTIFIER字符串添加鼠标取词功能\n      this.addPopoverByIdentifierArray();\n    }\n  }\n\n  onDivContentChange = (evt) => {\n    if (document.getElementsByClassName(\"line0\").length === 0 && evt.key === \"Backspace\") {\n      alert('当前在首行，无法再进行回退')\n      return;\n    }\n    if (this.keyToIngore.indexOf(evt.key) >= 0) {\n      return;\n    }\n\n    let bookmark = undefined;\n    if (evt.key !== \"Enter\") {\n      //使用rangy组件确认光标能回到原来的位置\n      bookmark = rangy.getSelection().getBookmark(this.divInstance);\n    }\n\n    //每当有输入只重新词法解析当前行\n    let currentLine = this.getCaretLineNode();\n    for (let i = 0; i < currentLine.childNodes.length; i++) {\n      if (\n        currentLine.childNodes[i].className === this.keyWordClass ||\n        currentLine.childNodes[i].className === this.identifierClass\n      ) {\n        const child = currentLine.childNodes[i];\n        const t = document.createTextNode(child.innerText);\n        currentLine.replaceChild(t, child);\n      }\n    }\n\n    //把所有相邻的text node 合并成一个\n    currentLine.normalize();\n    this.identifierElementArray = [];\n    this.changeNode(currentLine);\n    this.hightLightSyntax();\n    this.preparePopoverForIdentifers();\n\n    if (evt.key !== \"Enter\") {\n      rangy.getSelection().moveToBookmark(bookmark);\n    }\n  }\n\n  onClickDiv() {\n    /*\n        只有把pointerEvents设置为none，我们才能抓取鼠标在每行\n        数字处点击的信息，但是设置后mouseenter消息就不能接收到\n        于是当我们把鼠标挪到变量上方时，无法显现popover\n        */\n    const lineSpans = document.getElementsByClassName(this.lineSpanNode) as HTMLCollectionOf<HTMLElement>;\n    for (let i = 0; i < lineSpans.length; i++) {\n      lineSpans[i].style.pointerEvents = \"none\";\n    }\n  }\n  //\n  // onMouseEnter() {\n  //   /*\n  //       要想让popover控件出现，必须接收mouseenter时间，\n  //       只有把pointerEvent设置为空而不是none时，这个时间才能传递给\n  //       span\n  //       */\n  //   const lineSpans = document.getElementsByClassName(this.lineSpanNode);\n  //   for (let i = 0; i < lineSpans.length; i++) {\n  //     lineSpans[i].style.pointerEvents = \"\";\n  //   }\n  // }\n\n  render() {\n    const textAreaStyle = {\n      height: 480,\n      border: \"1px solid black\",\n      counterReset: \"line\",\n      fontFamily: \"monospace\",\n    };\n\n    return (\n      <div>\n        <Popover\n          placement=\"top\"\n          color=\"white\"\n          content={this.state.popoverStyle.content}\n          title={this.state.popoverStyle.title}\n          id=\"identifier-show\"\n        >\n          <div\n            style={textAreaStyle}\n            onKeyUp={this.onDivContentChange}\n            ref={(ref) => {\n              this.divInstance = ref;\n            }}\n            contentEditable\n          >\n          </div>\n        </Popover>\n      </div>\n    );\n  }\n}\n","/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEvaluator/MonkeyEvaluator.ts",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerEvaluator/EvaluatorCtr.ts",[],"/Users/keshawn/Desktop/toy-compiler/src/MonkeyCompilerIDE.tsx",[],{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","replacedBy":"71"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","replacedBy":"71"},{"ruleId":"68","replacedBy":"72"},{"ruleId":"70","replacedBy":"73"},{"ruleId":"68","replacedBy":"72"},{"ruleId":"70","replacedBy":"73"},{"ruleId":"74","severity":1,"message":"75","line":429,"column":11,"nodeType":"76","messageId":"77","endLine":429,"endColumn":23},"no-native-reassign",["78"],"no-negated-in-lhs",["79"],["78"],["79"],"@typescript-eslint/no-unused-vars","'PopoverStyle' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]